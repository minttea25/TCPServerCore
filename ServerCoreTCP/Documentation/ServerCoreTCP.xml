<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ServerCoreTCP</name>
    </assembly>
    <members>
        <member name="T:NetCore.RecvBuffer">
            <summary>
            The buffer for Receive using byte ArraySegment
            </summary>
        </member>
        <member name="F:NetCore.RecvBuffer._readPtr">
            <summary>
            Pointer of reading in the buffer
            </summary>
        </member>
        <member name="F:NetCore.RecvBuffer._writePtr">
            <summary>
            Pointer of writing in the buffer
            </summary>
        </member>
        <member name="P:NetCore.RecvBuffer.DataSize">
            <summary>
            Get size of written data.
            </summary>
        </member>
        <member name="P:NetCore.RecvBuffer.FreeSize">
            <summary>
            Get writable size of the buffer now.
            </summary>
        </member>
        <member name="P:NetCore.RecvBuffer.DataSegment">
            <summary>
            Return the byte segment of the written data.
            </summary>
        </member>
        <member name="P:NetCore.RecvBuffer.WriteSegment">
            <summary>
            Return the writable byte segment.
            </summary>
        </member>
        <member name="M:NetCore.RecvBuffer.CleanUp">
            <summary>
            Pulls the data to the front of the buffer and cleans it up. (Free up space of buffer)
            </summary>
        </member>
        <member name="M:NetCore.RecvBuffer.ClearBuffer">
            <summary>
            Reset the buffer.
            </summary>
        </member>
        <member name="M:NetCore.RecvBuffer.OnRead(System.Int32)">
            <summary>
            Move the read pointer of the recvbuffer.
            </summary>
            <param name="numOfBytes">The length of bytes to check the data.</param>
            <returns>False if the numOfBytes is bigger than current data size.<br/>True, otherwise.</returns>
        </member>
        <member name="M:NetCore.RecvBuffer.OnWrite(System.Int32)">
            <summary>
            Move the write pointer of the recvbuffer.
            </summary>
            <param name="numOfBytes">The length of bytes to check the data.</param>
            <returns>False if the numOfBytes is bigger than current-writable size.<br/>True, otherwise.</returns>
        </member>
        <member name="T:NetCore.SendBufferTLS">
            <summary>
            Each thread sends data with this.<br/>It has SendBuffer in Thread-Local-Storage.
            </summary>
        </member>
        <member name="M:NetCore.SendBufferTLS.Reserve(System.Int32)">
            <summary>
            Helper method of SendBuffer.Reserve
            </summary>
            <param name="reserveSize">The size to reserve.</param>
            <returns>The segment of Memory reserved</returns>
        </member>
        <member name="M:NetCore.SendBufferTLS.Return(System.Int32)">
            <summary>
            Helper method of SendBuffer.Return
            </summary>
            <param name="usedSize">The size used actually.</param>
            <returns>The segment of array used</returns>
        </member>
        <member name="T:NetCore.SendBuffer">
            <summary>
            The buffer for Send using byte array.
            </summary>
        </member>
        <member name="M:NetCore.SendBuffer.Reserve(System.Int32)">
            <summary>
            Return a segment which can be used of the size of reserveSize.
            </summary>
            <param name="reserveSize"></param>
            <returns>If there is no enough size to reserve, returns null.</returns>
        </member>
        <member name="M:NetCore.SendBuffer.Return(System.Int32)">
            <summary>
            Return the used segment actually after calling Reserve.
            </summary>
            <param name="usedSize">Used buffer size actullay</param>
            <returns>The segment of the actually used buffer.</returns>
        </member>
        <member name="M:NetCore.SendBuffer.Use(System.Int32)">
            <summary>
            Return the segment with that size. (reserve + return)<br/>If there is not enough size, returns the segment after setting usedSize 0.
            </summary>
            <param name="size">The size to get segment.</param>
            <returns>The segment of the buffer with the size.</returns>
        </member>
        <member name="T:NetCore.Core.Global">
            <summary>
            The class that contains global members in Core.<br/>It will be initialized when the service starts.<br/>Some members can be used in user-codes.
            </summary>
        </member>
        <member name="F:NetCore.Core.Global.G_Stopwatch">
            <summary>
            JobTimer and PacketSession uses this stopwatch globally.
            </summary>
        </member>
        <member name="M:NetCore.Core.Global.Init">
            <summary>
            It will be called when the service starts.
            </summary>
        </member>
        <member name="T:NetCore.Job.ActionSerializer">
            <summary>
            This is ActionSerilizer class for executing actions in one thread. 
            <br/>If you want to user parameters, use IJobSerializer. 
            <br/>It need to be called `Flush()` manually.
            <br/>When `Flush()` called, the it will invoke all actions in the queue.
            </summary>
        </member>
        <member name="T:NetCore.Job.ActionSerializerAuto">
            <summary>
            This is ActionSerializerAuto class for executing actions in one thread.
            <br/>If you want to user parameters, use IJobSerializerAuto.
            <br/>When `Add()` called, it will begin to invoke actions in the queue if any thread is not flushing.
            <br/>At this time, other `Add()` can be called and it just adds a action to a queue.
            </summary>
        </member>
        <member name="T:NetCore.Job.ICancelable">
            <summary>
            The interface of cancelable job.
            </summary>
        </member>
        <member name="T:NetCore.Job.CancelableJob">
            <summary>
            The cancelable job object which is used in JobTimer.<br/>Set `Canceled` to false when you want to cancel to invoke this job.
            </summary>
        </member>
        <member name="P:NetCore.Job.CancelableJob.Canceled">
            <summary>
            Set this value to false if you want to cancel to invoke this job.
            </summary>
        </member>
        <member name="T:NetCore.Job.IJob">
            <summary>
            The interface of Job.
            </summary>
        </member>
        <member name="T:NetCore.Job.Job">
            <summary>
            The job object which is used in JobSerialier and JobTimer.<br/>Up to 5 arguments are provided.
            </summary>
        </member>
        <member name="T:NetCore.Job.IJobSerializer">
            <summary>
            The interface of JobSerializer.
            </summary>
        </member>
        <member name="M:NetCore.Job.IJobSerializer.Flush">
            <summary>
            Invokes all jobs in the queue.
            </summary>
        </member>
        <member name="M:NetCore.Job.IJobSerializer.Add(NetCore.Job.IJob)">
            <summary>
            Add job to serializer.
            </summary>
            <param name="job"></param>
        </member>
        <member name="T:NetCore.Job.JobSerializer">
            <summary>
            This is JobSerilizer class for executing jobs in one thread with serializing the jobs. 
            <br/>It need to be called `Flush()` manually.
            <br/>When `Flush()` called, it will invoke all actions in the queue.
            </summary>
        </member>
        <member name="T:NetCore.Job.JobSerializerWithTimer">
            <summary>
            This is JobSerilizer class for executing jobs in one thread with serializing the jobs. 
            <br/>It calls `Flush()` automatically, so you don't need to call `Flush()` manually.
            <br/>The added cancelable jobs are executed when the reserved time comes. (miiliseconds)
            <br/>It contains the whole functions of JobSerializer. (It is derived from JobSerializer)
            </summary>
        </member>
        <member name="T:NetCore.Job.IUseJobTimer">
            <summary>
            The interface of the JobTimer using Cancelable jobs.
            </summary>
        </member>
        <member name="T:NetCore.Job.JobTimer">
            <summary>
            It is stored in the priority queue at the scheduled time, and when that time comes, it is automatically flushed and the job is executed. 
            <br/>If the Canceled value of the job is false, the job will not be executed.
            <br/>It uses the StopWatch in Global.
            </summary>
        </member>
        <member name="M:NetCore.Job.JobTimer.AddAfter(NetCore.Job.IJob,System.Int64)">
            <summary>
            Add Cancelable Job in the queue.
            </summary>
            <param name="job">The Job object</param>
            <param name="millisecondsAfter">The reserved time to be executed</param>
            <returns>The reserved Cancelable job.</returns>
        </member>
        <member name="T:NetCore.CLogger.CoreLogger">
            <summary>
            A class for logging in NetCore.
            </summary>
        </member>
        <member name="P:NetCore.CLogger.CoreLogger.CLogger">
            <summary>
            Logger can be created with 'CreateLoggerWithFlag' or user's needs in directly.
            </summary>
        </member>
        <member name="T:NetCore.CLogger.LoggerConfig">
            <summary>
            The default values are from the default values of LoggerConfiguration, and the defualt encoding is UTF8.
            </summary>
        </member>
        <member name="M:NetCore.CLogger.LoggerHelper.GetFileName(System.String,System.String)">
            <summary>
            Return a filename based on DateTime.Now.
            </summary>
            <param name="dirPath">The root directory of the file.</param>
            <param name="extension">The extension of log file. e.g. log, txt, ...</param>
            <returns>A filename based on DateTime.Now</returns>
        </member>
        <member name="T:NetCore.Connector">
            <summary>
            The connector object to connect to other endpoint.<br/>The default connected count is 1, and it also provides the multiple connections for doing test.
            </summary>
        </member>
        <member name="P:NetCore.Connector.ClientService">
            <summary>
            The referenced ClientService
            </summary>
        </member>
        <member name="P:NetCore.Connector.ConnectionCount">
            <summary>
            The count of the connections which is configured at first.
            </summary>
        </member>
        <member name="M:NetCore.Connector.#ctor(NetCore.ClientService,NetCore.Session[],System.Net.IPEndPoint,NetCore.ClientServiceConfig,System.Action{System.Net.Sockets.SocketError})">
            <summary>
            The constructor of the connector.
            </summary>
            <param name="clientService">The configured client service</param>
            <param name="session">The empty sessions are created in advance</param>
            <param name="endPoint">The endpoint to connect</param>
            <param name="config">The ClientServiceConfig that contains information of service</param>
            <param name="connectFailedCallback">The callback which is invoked when the connection is failed.</param>
        </member>
        <member name="T:NetCore.Listener">
            <summary>
            The listener object to listen for waiting connections of others.
            </summary>
        </member>
        <member name="P:NetCore.Listener.Port">
            <summary>
            The opened port for listening
            </summary>
        </member>
        <member name="P:NetCore.Listener.Backlog">
            <summary>
            The count of backlogs of listening
            </summary>
        </member>
        <member name="P:NetCore.Listener.RegisterCount">
            <summary>
            The count of registered that are configured in advance.
            </summary>
        </member>
        <member name="P:NetCore.Listener.ServerService">
            <summary>
            The referenced ServerService.
            </summary>
        </member>
        <member name="M:NetCore.Listener.#ctor(NetCore.ServerService,System.Net.IPEndPoint,System.Net.Sockets.AddressFamily,NetCore.ServerServiceConfig)">
            <summary>
            Create a socket and bind the endpoint.
            </summary>
            <param name="service">The ServerService Instance</param>
            <param name="endPoint">The endpoint to bind to socket</param>
            <param name="addressFamily"></param>
            <param name="config">The configs of server service</param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:NetCore.Listener.StartListen">
            <summary>
            Place the socket in a listening state.
            </summary>
        </member>
        <member name="M:NetCore.Listener.RegisterAccept(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Register as waiting for Accept
            </summary>
            <param name="eventArgs">An object that contains the socket-async-event data</param>
        </member>
        <member name="M:NetCore.Listener.OnAcceptCompleted(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Callback that is called when Accept.
            </summary>
            <param name="eventArgs">An object that contains the socket-async-event data</param>
        </member>
        <member name="T:NetCore.Service.ServiceTypes">
            <summary>
            The types of service.
            </summary>
        </member>
        <member name="P:NetCore.Service.ServiceType">
            <summary>
            The ServiceType
            </summary>
        </member>
        <member name="P:NetCore.Service.SAEATotalPoolCount">
            <summary>
            The total count of SocketAsyncEventArgs in the pool.
            </summary>
        </member>
        <member name="P:NetCore.Service.SAEACurrentPooledCount">
            <summary>
            The count of the currently pooled SocketAsyncEventArgs in the pool.
            </summary>
        </member>
        <member name="M:NetCore.Service.#ctor(NetCore.Service.ServiceTypes,System.Int32)">
            <summary>
            The constructor of Service.
            </summary>
            <param name="serviceType">The service type</param>
            <param name="saeaPoolCount">The count of SAEA of the pool</param>
        </member>
        <member name="T:NetCore.ServerService">
            <summary>
            The service that can listen the connections of others.
            </summary>
        </member>
        <member name="P:NetCore.ServerService.SessionTotalPoolCount">
            <summary>
            The total count of the sessions in the pool.
            </summary>
        </member>
        <member name="P:NetCore.ServerService.SessionCurrentPooledCount">
            <summary>
            The count of the currently pooled sessions in the pool.
            </summary>
        </member>
        <member name="P:NetCore.ServerService.Port">
            <summary>
            The listening port number.
            </summary>
        </member>
        <member name="P:NetCore.ServerService.ListenerBackLog">
            <summary>
            The count of the listening backlogs.
            </summary>
        </member>
        <member name="P:NetCore.ServerService.ListenrRegisterCount">
            <summary>
            The count of the registered counts of the listener.
            </summary>
        </member>
        <member name="P:NetCore.ServerService.ConnectedSessionCount">
            <summary>
            The count of connected sessions. <br/>  = SessionTotalPoolCount - SessionCurrentPooledCount
            </summary>
        </member>
        <member name="M:NetCore.ServerService.#ctor(System.Net.IPEndPoint,System.Func{NetCore.Session},NetCore.ServerServiceConfig)">
            <summary>
            The constructor of serverservice.<br/>Note: The sessions are created in the pool before formed connection.
            </summary>
            <param name="endPoint">The endpoint to be opened.</param>
            <param name="emptySessionFactory">The factory of the empty session.</param>
            <param name="config">The configs of the server service.</param>
        </member>
        <member name="M:NetCore.ServerService.Start">
            <summary>
            Starts the service. (Starts to listen)
            </summary>
        </member>
        <member name="M:NetCore.ServerService.Stop">
            <summary>
            Stop the service.
            </summary>
        </member>
        <member name="T:NetCore.ClientService">
            <summary>
            The service for connecting to other.
            </summary>
        </member>
        <member name="P:NetCore.ClientService.ConnectionCount">
            <summary>
            The count of connections configured in advance.
            </summary>
        </member>
        <member name="M:NetCore.ClientService.#ctor(System.Net.IPEndPoint,System.Func{NetCore.Session},NetCore.ClientServiceConfig,System.Action{System.Net.Sockets.SocketError})">
            <summary>
            The constructor of clientservice.<br/>Note: The sessions are created before formed connection.
            </summary>
            <param name="endPoint">The endpoint to connect to.</param>
            <param name="emptySessionFactory">The factory of the empty session.</param>
            <param name="config">The configs of the client service.</param>
            <param name="connectFailedCallback">The callback which is invoked when the connection is failed.</param>
        </member>
        <member name="M:NetCore.ClientService.Start">
            <summary>
            Start the servie. (Starts to connect)
            </summary>
        </member>
        <member name="M:NetCore.ClientService.Stop">
            <summary>
            Stop the service.
            </summary>
        </member>
        <member name="F:NetCore.ClientServiceConfig.SAEACountMultiplier">
            <summary>
            The value of setting the margin counts of the SocketAsyncEventArgs.
            </summary>
        </member>
        <member name="P:NetCore.ClientServiceConfig.SocketAsyncEventArgsPoolCount">
            <summary>
            The count of SocketAsyncEventArgs must be larger than (SessionPoolCount * 2 + RegisterListenCount)
            </summary>
        </member>
        <member name="P:NetCore.ClientServiceConfig.ClientServiceSessionCount">
            <summary>
            The session count of the client service.
            </summary>
        </member>
        <member name="P:NetCore.ClientServiceConfig.ReuseAddress">
            <summary>
            Use reuse-address option of the socket.
            </summary>
        </member>
        <member name="M:NetCore.ClientServiceConfig.GetDefault(System.Int32)">
            <summary>
            ReuseAddress: true
            </summary>
            <param name="sessionCount">SessionCount</param>
            <returns></returns>
        </member>
        <member name="M:NetCore.ClientServiceConfig.GetSAEAPoolCount(System.Int32)">
            <summary>
            Calculate an additional margin of 10 percent. (SessionCount * 2 )
            </summary>
            <param name="sessionCount">SessionCount</param>
            <returns></returns>
        </member>
        <member name="F:NetCore.ServerServiceConfig.SAEACountMultiplier">
            <summary>
            The value of setting the margin counts of the SocketAsyncEventArgs.
            </summary>
        </member>
        <member name="P:NetCore.ServerServiceConfig.SocketAsyncEventArgsPoolCount">
            <summary>
            The count of SocketAsyncEventArgs must be larger than (SessionPoolCount * 2 + RegisterListenCount)
            </summary>
        </member>
        <member name="P:NetCore.ServerServiceConfig.ListenerBacklogCount">
            <summary>
            The count of backlogs of listening.
            </summary>
        </member>
        <member name="P:NetCore.ServerServiceConfig.RegisterListenCount">
            <summary>
            If 0, the listener will throw exception. It must be larger than 0.
            </summary>
        </member>
        <member name="P:NetCore.ServerServiceConfig.NoDelay">
            <summary>
            Use Nagle algorithm option of the socket.
            </summary>
        </member>
        <member name="P:NetCore.ServerServiceConfig.ReuseAddress">
            <summary>
            Reuse address option of the socket
            </summary>
        </member>
        <member name="P:NetCore.ServerServiceConfig.Linger">
            <summary>
            If 0, linger set false, otherwise set the time in seconds.
            </summary>
        </member>
        <member name="M:NetCore.ServerServiceConfig.GetDefault(System.Int32,System.Int32)">
            <summary>
            NoDelay: false, ReuseAddress: true, Linger: false
            </summary>
            <param name="sessionCount">SessionPoolCount</param>
            <param name="registerListenCount">RegisterListenCount</param>
            <returns></returns>
        </member>
        <member name="M:NetCore.ServerServiceConfig.GetSAEAPoolCount(System.Int32,System.Int32)">
            <summary>
            Calculate an additional margin of 10 percent. (SessionPoolCount * 2 + RegisterListenCount)
            </summary>
            <param name="sessionPoolCount">SessionPoolCount</param>
            <param name="registerListenCount">RegisterListenCount</param>
            <returns></returns>
        </member>
        <member name="T:NetCore.Session">
            <summary>
            Session object of the core.
            </summary>
        </member>
        <member name="P:NetCore.Session.SessionId">
            <summary>
            Unique id of Session.
            </summary>
        </member>
        <member name="P:NetCore.Session.ConnectedEndPoint">
            <summary>
            [Nullable] Connected Endpoint.<br/>(Null if the socket is null or not connected)
            </summary>
        </member>
        <member name="P:NetCore.Session.Socket">
            <summary>
            The socket of the session.
            </summary>
        </member>
        <member name="F:NetCore.Session._connected">
            <summary>
            The value to check the session connected;<br/>0: disconnected<br/>1: connected
            </summary>
        </member>
        <member name="F:NetCore.Session._lock">
            <summary>
            Note: Send/Recv can be occurred in multiple threads
            </summary>
        </member>
        <member name="M:NetCore.Session.Dispatch(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Dispatch the socket event.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NetCore.Session.OnConnected(System.Net.EndPoint)">
            <summary>
            Called when the socket is connected.
            </summary>
            <param name="endPoint">The endpoint of connected socket</param>
        </member>
        <member name="M:NetCore.Session.OnRecv(System.ArraySegment{System.Byte},System.Int32,System.Int32)">
            <summary>
            Called when the socket received data.
            </summary>
            <param name="buffer">Received buffer</param>
            <param name="offset">offset of the data</param>
            <param name="count">length of the data</param>
        </member>
        <member name="M:NetCore.Session.OnSend(System.Int32)">
            <summary>
            Called when the socket sent data.
            </summary>
            <param name="numOfBytes">The length of bytes transferred.</param>
        </member>
        <member name="M:NetCore.Session.OnDisconnected(System.Net.EndPoint,System.Object)">
            <summary>
            Called when the socket is disconnected.
            </summary>
            <param name="endPoint">The end point of the socket.</param>
            <param name="error">The additional object of error</param>
        </member>
        <member name="M:NetCore.Session.OnRecvProcess(System.ArraySegment{System.Byte})">
            <summary>
            Override this method to process the received buffer.
            </summary>
            <param name="buffer">The buffer received on socket.</param>
            <returns>The length of processed bytes.</returns>
        </member>
        <member name="M:NetCore.Session.#ctor">
            <summary>
            Constructor of Session.
            </summary>
        </member>
        <member name="M:NetCore.Session.Init(System.Net.Sockets.Socket)">
            <summary>
            A session must be initialized with this method with socket.
            </summary>
            <param name="socket">The socket to be connected to the session.</param>
        </member>
        <member name="M:NetCore.Session.Send(System.ArraySegment{System.Byte})">
            <summary>
            [lock] Send data to endpoint.
            </summary>
            <param name="sendBuffer">buffer of data</param>
            <exception cref="T:System.Exception">if the session is not connected or the length of buffer is 0</exception>
            <exception cref="T:System.ArgumentNullException">if buffer is null</exception>
        </member>
        <member name="M:NetCore.Session.Send(System.Collections.Generic.List{System.ArraySegment{System.Byte}})">
            <summary>
            [lock] Send a list of data to endpoint of the socket.
            </summary>
            <param name="sendBufferList">A list of serialized data to send</param>
            <exception cref="T:System.Exception">if sendBufferList is empty.</exception>
        </member>
        <member name="M:NetCore.Session.RegisterSend">
            <summary>
            Send asynchrously all buffer in sendPendingList.
            </summary>
        </member>
        <member name="M:NetCore.Session.RegisterRecv">
            <summary>
            Receive asynchrously.
            </summary>
        </member>
        <member name="M:NetCore.Session.OnSendCompleted(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Callback that is called when send-operation is completed.
            </summary>
            <param name="eventArgs">An object that contains the socket-async-send-event data</param>
        </member>
        <member name="M:NetCore.Session.OnRecvCompleted(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Callback that is called when recv-operation is completed.
            </summary>
            <param name="eventArgs">An object that contains the socket-async-recv-event data</param>
        </member>
        <member name="M:NetCore.Session.Disconnect(System.String)">
            <summary>
            Close the connection and the socket and clear the session.
            </summary>
        </member>
        <member name="M:NetCore.Session.OnDisconnectedCompleted(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Callback of disconnect operation.
            </summary>
            <param name="eventArgs"></param>
        </member>
        <member name="T:NetCore.SessionPool">
            <summary>
            The pool of the sessions.
            </summary>
        </member>
        <member name="P:NetCore.SessionPool.TotalPoolCount">
            <summary>
            The total count of the session of the pool.
            </summary>
        </member>
        <member name="P:NetCore.SessionPool.CurrentPooledCount">
            <summary>
            The count of the curently pooled sessions.
            </summary>
        </member>
        <member name="M:NetCore.SessionPool.CreateNew">
            <summary>
            If there is no more pooled session, makes new one.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetCore.SocketAsyncEventArgsPool">
            <summary>
            The pool of the SocketAsyncEventArgs of the socket events.
            </summary>
        </member>
        <member name="P:NetCore.SocketAsyncEventArgsPool.TotalPoolCount">
            <summary>
            The total count of the SocketAsyncEventArgs of the pool.
            </summary>
        </member>
        <member name="P:NetCore.SocketAsyncEventArgsPool.CurrentPooledCount">
            <summary>
            The count of the currently pooled SocketAsyncEventArgs.
            </summary>
        </member>
        <member name="M:NetCore.SocketAsyncEventArgsPool.CreateNew">
            <summary>
            If there is no more pooled SocketAsyncEventArgs, makes new one.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetCore.SocketEventToken">
            <summary>
            Object that distinguishes type of the socket event.<br/>It is used with the Socket.UserToken.
            </summary>
        </member>
        <member name="M:NetCore.Flatbuffers.PacketWrapper.Serialize(Google.FlatBuffers.FlatBufferBuilder,System.UInt16)">
            <summary>
            Wrap the data with id
            </summary>
            <param name="fb">the finished FlatBufferBuilder</param>
            <param name="id">packet id</param>
            <returns>The wrapped buffer</returns>
        </member>
        <member name="M:NetCore.Flatbuffers.PacketWrapper.WritePacketHeader(System.UInt16,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Write id (2 bytes) and size (2 bytes) to buffer of offset with Little Endian.
            </summary>
            <param name="id">packet id</param>
            <param name="size">size of packet</param>
            <param name="buffer">buffer to write</param>
            <param name="ofs">offset to write</param>
        </member>
        <member name="T:NetCore.PacketSession">
            <summary>
            Session to pend packets and send them manually. (Call FlushSend())
            </summary>
        </member>
        <member name="M:NetCore.PacketSession.Send(Google.FlatBuffers.FlatBufferBuilder,System.UInt16)">
            <summary>
            Serialize finished FlatBufferBuilder with id and send it.
            </summary>
            <param name="fb">FlatBufferBuilder which is finished serialization.</param>
            <param name="id">packet id</param>
        </member>
        <member name="M:NetCore.PacketSession.Send(System.ArraySegment{System.Byte})">
            <summary>
            Send raw data
            </summary>
            <param name="data">buffer to send</param>
        </member>
        <member name="M:NetCore.PacketSession.OnRecvProcess(System.ArraySegment{System.Byte})">
            <summary>
            Slices the buffer that contains multiple data and calls OnRecv of the session with sliced data.
            </summary>
            <param name="buffer">The buffer that the socket received at once</param>
            <returns>The analyzed total length of the data</returns>
        </member>
        <member name="M:NetCore.PacketSession.FlushSend">
            <summary>
            Flushes serialized data in the pending queue according to specified conditions.
            </summary>
        </member>
        <member name="T:NetCore.Utils.Base128Encoding">
            <summary>
            Static class for encoding of variant length with uint value.<br/>(Same as the way if encoding in the Protobuf about variant encoding)
            </summary>
        </member>
        <member name="M:NetCore.Utils.Extensions.FromUInt16(System.UInt16,System.Span{System.Byte},System.Int32)">
            <summary>
            Converts the value to bytes at the offset starts in the buffer.<br/> 
            The buffer must have enough space.
            </summary>
            <param name="value">The value to convert</param>
            <param name="buffer">The buffer</param>
            <param name="offset">The offset of the buffer</param>
        </member>
        <member name="M:NetCore.Utils.Extensions.FromUInt16(System.UInt16,System.Span{System.Byte},System.Int32@)">
            <summary>
            Converts the value to bytes at the offset starts in the buffer.<br/>
            The buffer must have enough space.
            Note: The offset is reference value.<br/>
            </summary>
            <param name="value">The value to convert</param>
            <param name="buffer">The buffer</param>
            <param name="offset">The offset of the buffer</param>
        </member>
        <member name="M:NetCore.Utils.Extensions.FromInt16(System.Int16,System.Span{System.Byte},System.Int32)">
            <summary>
            Converts the value to bytes at the offset starts in the buffer.<br/> 
            The buffer must have enough space.
            </summary>
            <param name="value">The value to convert</param>
            <param name="buffer">The buffer</param>
            <param name="offset">The offset of the buffer</param>
        </member>
        <member name="M:NetCore.Utils.Extensions.FromInt16(System.Int16,System.Span{System.Byte},System.Int32@)">
            <summary>
            Converts the value to bytes at the offset starts in the buffer.<br/>
            The buffer must have enough space.
            Note: The offset is reference value.<br/>
            </summary>
            <param name="value">The value to convert</param>
            <param name="buffer">The buffer</param>
            <param name="offset">The offset of the buffer</param>
        </member>
        <member name="M:NetCore.Utils.Extensions.FromUInt32(System.UInt32,System.Span{System.Byte},System.Int32)">
            <summary>
            Converts the value to bytes at the offset starts in the buffer.<br/> 
            The buffer must have enough space.
            </summary>
            <param name="value">The value to convert</param>
            <param name="buffer">The buffer</param>
            <param name="offset">The offset of the buffer</param>
        </member>
        <member name="M:NetCore.Utils.Extensions.FromUInt32(System.UInt32,System.Span{System.Byte},System.Int32@)">
            <summary>
            Converts the value to bytes at the offset starts in the buffer.<br/>
            The buffer must have enough space.
            Note: The offset is reference value.<br/>
            </summary>
            <param name="value">The value to convert</param>
            <param name="buffer">The buffer</param>
            <param name="offset">The offset of the buffer</param>
        </member>
        <member name="M:NetCore.Utils.Extensions.FromInt32(System.Int32,System.Span{System.Byte},System.Int32)">
            <summary>
            Converts the value to bytes at the offset starts in the buffer.<br/> 
            The buffer must have enough space.
            </summary>
            <param name="value">The value to convert</param>
            <param name="buffer">The buffer</param>
            <param name="offset">The offset of the buffer</param>
        </member>
        <member name="M:NetCore.Utils.Extensions.FromInt32(System.Int32,System.Span{System.Byte},System.Int32@)">
            <summary>
            Converts the value to bytes at the offset starts in the buffer.<br/>
            The buffer must have enough space.
            Note: The offset is reference value.<br/>
            </summary>
            <param name="value">The value to convert</param>
            <param name="buffer">The buffer</param>
            <param name="offset">The offset of the buffer</param>
        </member>
        <member name="M:NetCore.Utils.Extensions.ToUInt16(System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            Converts the buffer starts at the offset to value. <br/>
            The bytes starts at the offet of the buffer must have correct data to convert to the type of value.
            </summary>
            <param name="buffer">The buffer to convert</param>
            <param name="offset">The offset of the buffer</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:NetCore.Utils.Extensions.ToUInt16(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Converts the buffer starts at the offset to value. <br/>
            The bytes starts at the offet of the buffer must have correct data to convert to the type of value.<br/>
            Note: The offset is reference value.
            </summary>
            <param name="buffer">The buffer to convert</param>
            <param name="offset">The offset of the buffer</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:NetCore.Utils.Extensions.ToInt16(System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            Converts the buffer starts at the offset to value. <br/>
            The bytes starts at the offet of the buffer must have correct data to convert to the type of value.
            </summary>
            <param name="buffer">The buffer to convert</param>
            <param name="offset">The offset of the buffer</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:NetCore.Utils.Extensions.ToInt16(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Converts the buffer starts at the offset to value. <br/>
            The bytes starts at the offet of the buffer must have correct data to convert to the type of value.<br/>
            Note: The offset is reference value.
            </summary>
            <param name="buffer">The buffer to convert</param>
            <param name="offset">The offset of the buffer</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:NetCore.Utils.Extensions.ToUInt32(System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            Converts the buffer starts at the offset to value. <br/>
            The bytes starts at the offet of the buffer must have correct data to convert to the type of value.
            </summary>
            <param name="buffer">The buffer to convert</param>
            <param name="offset">The offset of the buffer</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:NetCore.Utils.Extensions.ToUInt32(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Converts the buffer starts at the offset to value. <br/>
            The bytes starts at the offet of the buffer must have correct data to convert to the type of value.<br/>
            Note: The offset is reference value.
            </summary>
            <param name="buffer">The buffer to convert</param>
            <param name="offset">The offset of the buffer</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:NetCore.Utils.Extensions.ToInt32(System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            Converts the buffer starts at the offset to value. <br/>
            The bytes starts at the offet of the buffer must have correct data to convert to the type of value.
            </summary>
            <param name="buffer">The buffer to convert</param>
            <param name="offset">The offset of the buffer</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:NetCore.Utils.Extensions.ToInt32(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Converts the buffer starts at the offset to value. <br/>
            The bytes starts at the offet of the buffer must have correct data to convert to the type of value.<br/>
            Note: The offset is reference value.
            </summary>
            <param name="buffer">The buffer to convert</param>
            <param name="offset">The offset of the buffer</param>
            <returns>The converted value</returns>
        </member>
        <member name="T:NetCore.Utils.PriorityQueue`1">
            <summary>
            PriorityQueue (If the type is numeric, Peek() will return highest value in default.)
            <br/>NOTE: If count==0, `Peek()` and `Dequeue()` will return DEFAULT value.
            <br/>Use `TryPeek` and `TryDequeue` safely with primitive types.
            </summary>
            <typeparam name="T">System.IComparable: the comparable object</typeparam>
        </member>
        <member name="T:NetCore.Utils.PriorityQueueCompare`1">
            <summary>
            PrioirtyQueue with user-defined Compare function.
            </summary>
            <typeparam name="T">Any object</typeparam>
        </member>
        <member name="M:NetCore.Utils.PriorityQueueCompare`1.#ctor(System.Comparison{`0})">
            <summary>
            PrioirtyQueue with user-defined Compare function.
            </summary>
            <param name="compare">The function to compare two objects.</param>
        </member>
        <member name="T:NetCore.Utils.ConcurrentPriorityQueue`1">
            <summary>
            PriorityQueue (If the type is numeric, Peek() will return highest value.)
            </summary>
            <typeparam name="T">System.IComparable: the comparable object</typeparam>
        </member>
        <member name="T:NetCore.Utils.ConcurrentPriorityQueueCompare`1">
            <summary>
            PrioirtyQueue with user-defined Compare function.
            </summary>
            <typeparam name="T">Any object</typeparam>
        </member>
        <member name="M:NetCore.Utils.ConcurrentPriorityQueueCompare`1.#ctor(System.Comparison{`0})">
            <summary>
            PrioirtyQueue with user-defined Compare function.
            </summary>
            <param name="compare">The function to compare two objects.</param>
        </member>
        <member name="M:NetCore.Utils.TaskManager.SetMain(System.Action)">
            <summary>
            The main task does not contain infite-loop for the action.
            </summary>
            <param name="mainTask"></param>
        </member>
        <member name="M:NetCore.Utils.TaskManager.AddTask(System.Action)">
            <summary>
            Add a new task that invokes the action infinitely with options of LongRunning.
            </summary>
            <param name="action"></param>
        </member>
        <member name="T:NetCore.Utils.ThreadManager">
            <summary>
            It uses Thread directly and is recommended in Debug mode for identifying the thread names.
            </summary>
        </member>
        <member name="M:NetCore.Utils.ThreadManager.#ctor(System.Int32)">
            <summary>
            The taskCount does not contains the main task.
            </summary>
            <param name="taskCount">The task count except main task.</param>
        </member>
        <member name="M:NetCore.Utils.ThreadManager.SetMainTask(System.Action,System.String)">
            <summary>
            Do not change the thread name before or after calling this function.
            </summary>
            <param name="mainTaskAction"></param>
            <param name="mainThreadName"></param>
        </member>
        <member name="M:NetCore.Utils.ThreadManager.AddTask(System.Action,System.String)">
            <summary>
            Do not change the thread name before or after calling this function.
            </summary>
            <param name="task"></param>
            <param name="threadName"></param>
        </member>
        <member name="M:NetCore.Utils.ThreadManager.StartTasks">
            <summary>
            Start all registered tasks. 
            NOTE: Each task will invoke repeatedly with `Thread.Sleep(0)` in infinite loop at each thread, but the main task will be called only invoke once.
            </summary>
        </member>
    </members>
</doc>
